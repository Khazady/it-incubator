{"version":3,"sources":["api/api.ts","features (pages)/TodolistsList/todolists-reducer.ts","features (pages)/TodolistsList/tasks-reducer.ts","app/store.ts","components (common)/AddItemForm/AddItemForm.tsx","components (common)/EditableSpan/EditableSpan.tsx","features (pages)/TodolistsList/Todolist/Task/Task.tsx","features (pages)/TodolistsList/Todolist/Todolist.tsx","features (pages)/TodolistsList/TodolistsList.tsx","app/App.tsx","index.tsx"],"names":["TaskStatuses","TaskPriorities","instance","axios","create","withCredentials","baseURL","headers","todolistsAPI","get","then","res","data","title","post","todolistId","delete","put","tasksAPI","taskId","model","initState","updateTaskTC","businessModel","dispatch","getState","task","tasks","find","t","id","serverModal","deadline","description","priority","startDate","status","type","updateTaskAC","console","warn","rootReducer","combineReducers","todolists","state","action","filter","tl","todolist","map","todoListId","stateCopy","forEach","store","createStore","applyMiddleware","thunk","window","AddItemForm","React","memo","props","log","useState","setTitle","error","setError","addItem","trim","TextField","value","onChange","e","currentTarget","onKeyPress","charCode","variant","label","helperText","IconButton","color","onClick","AddBox","EditableSpan","editMode","setEditMode","activateViewMode","autoFocus","onBlur","onDoubleClick","Task","useDispatch","RemoveTask","useCallback","removeTaskAC","ChangeTaskStatus","newStatusValue","checked","Completed","New","ChangeTaskTitle","newValue","key","className","Checkbox","Delete","Todolist","tasksForTodoList","allTodoListTasks","useSelector","addTask","item","addTaskTC","removeTodoList","removeTodolistAC","changeTodoListTitle","newTitle","changeTodoListTitleAC","changeFilter","changeTodoListFilterAC","useEffect","setTasksAC","items","ButtonGroup","Button","endIcon","Home","TodolistsList","addTodoList","addTodolistTC","Grid","container","style","padding","spacing","Paper","App","AppBar","position","Toolbar","edge","aria-label","Menu","open","Typography","Container","fixed","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.91bea76b.chunk.js","sourcesContent":["//DAL крайняя точка клиента перед сервером, поэтому здесь не может быть других импортов кроме axios\r\nimport axios from \"axios\";\r\n\r\nconst instance = axios.create({\r\n    withCredentials: true,\r\n    baseURL: \"https://social-network.samuraijs.com/api/1.1/\",\r\n    headers: {\r\n        \"API-KEY\": \"a13d3464-2e9e-4272-8cbf-d0d1a9048e02\"\r\n    }\r\n});\r\n\r\n\r\n//api\r\nexport const todolistsAPI = {\r\n    getTodolists() {\r\n        //оставляем в ответе только дату\r\n        //generic того, что нам возвращает этот метод (в документации)\r\n        return instance.get<Array<TodolistServerType>>(\"todo-lists\").then(res => res.data)\r\n    },\r\n    createTodolist(title: string) {\r\n        return instance.post<ResponseType<{item: TodolistServerType}>>(\"todo-lists\", {title: title}).then(res => res.data)\r\n    },\r\n    deleteTodolist(todolistId: string) {\r\n        return instance.delete<ResponseType>(`todo-lists/${todolistId}`).then(res => res.data)\r\n    },\r\n    updateTodolist(todolistId: string, title: string) {\r\n        return instance.put<ResponseType>(`todo-lists/${todolistId}`, {title: title}).then(res => res.data)\r\n    }\r\n}\r\nexport const tasksAPI = {\r\n    getTasks(todolistId: string) {\r\n        //получаем порцию тасок конкретного todolist\r\n        //generic того, что нам возвращает этот метод (в документации)\r\n        //в Item будет массив объектов {items:TaskType}\r\n        return instance.get<GetTaskResponse<Array<TaskType>>>(`todo-lists/${todolistId}/tasks`).then(res => res.data)\r\n    },\r\n    createTask(todolistId: string, title: string) {\r\n        return instance.post<ResponseType<{item: TaskType}>>(`todo-lists/${todolistId}/tasks`, {title: title}).then(res => res.data)\r\n    },\r\n    deleteTask(todolistId: string, taskId: string) {\r\n        return instance.delete<ResponseType>(`todo-lists/${todolistId}/tasks/${taskId}`).then(res => res.data)\r\n    },\r\n    updateTask(todolistId: string, taskId: string, model: UpdateTaskModelType) {\r\n        return instance.put<ResponseType<{item: TaskType}>>(`todo-lists/${todolistId}/tasks/${taskId}`, model).then(res => res.data)\r\n    }\r\n}\r\n\r\n\r\n// types\r\n\r\n//с API начинается разработка приложения, поэтому типы того, что приходит с сервера описываем в API\r\nexport type TodolistServerType = {\r\n    id: string\r\n    title: string\r\n    addedDate: string\r\n    order: number\r\n}\r\n//item это переменная, которую вставляем в generic при использовании (например <ResponseType<{item: TodolistType}>> ) --\r\n//-- значит, что в data будет item, в других случаях data - пустой объект ( <ResponseType<{}>> )\r\n//в generic можно передать дефолт значение, если не писать уточняющий generic, то Item = {}\r\ntype ResponseType<Item = {}> = {\r\n    resultCode: number,\r\n    messages: Array<string>\r\n    data: Item\r\n}\r\ntype GetTaskResponse<Item = {}> = {\r\n    error: string | null\r\n    totalCount: number\r\n    items: Item\r\n}\r\n//особый тип/переменная, расширяющий boolean, так как false и true не хватает для статусов (запросов)\r\nexport enum TaskStatuses {\r\n    New = 0,\r\n    InProgress = 1,\r\n    Completed = 2,\r\n    Draft = 3\r\n}\r\nexport enum TaskPriorities {\r\n    Low = 0,\r\n    Middle = 1,\r\n    High = 2,\r\n    Urgently = 3,\r\n    Later = 4\r\n}\r\nexport type TaskType = {\r\n    description: string | null\r\n    title: string\r\n    status: TaskStatuses\r\n    priority: TaskPriorities\r\n    startDate: string | null\r\n    deadline: string | null\r\n    id: string\r\n    todoListId: string\r\n    order: number\r\n    addedDate: string\r\n}\r\nexport type UpdateTaskModelType = {\r\n    title: string\r\n    description: string | null\r\n    status: TaskStatuses\r\n    priority: TaskPriorities\r\n    startDate: string | null\r\n    deadline: string | null\r\n}\r\n","import {Dispatch} from \"redux\";\r\nimport {todolistsAPI, TodolistServerType} from \"../../api/api\";\r\n\r\n//reducer\r\nconst initState: Array<TodolistBusinessType> = []\r\nexport const todolistsReducer = (state: Array<TodolistBusinessType> = initState, action: ActionsType): Array<TodolistBusinessType> => {\r\n    switch (action.type) {\r\n        case 'REMOVE-TODOLIST':\r\n            return state.filter(tl => tl.id !== action.id)\r\n        case 'ADD-TODOLIST':\r\n            //добавляем в серверный тудулист фильтр\r\n            return [{...action.todolist, filter: \"all\"}, ...state]\r\n        case 'CHANGE-TODOLIST-TITLE':\r\n            //если id листа == id в action, то возвращаем копию листа (...tl) и меняем title на тот, кот. в action\r\n            return state.map(tl => tl.id === action.id ? {...tl, title: action.title} : tl)\r\n        case 'CHANGE-TODOLIST-FILTER':\r\n            //если id листа == id в action, то возвращаем копию листа (...tl) и меняем filter на тот, кот. в action\r\n            return state.map(tl => tl.id === action.id ? {...tl, filter: action.filter} : tl)\r\n        case 'SET-TODOLISTS':\r\n            //на входе в этот AC приходит серверТайп, преобразовываем его в бизнесТайп, добавляя фильтр\r\n            return action.todolists.map(tl => ({...tl, filter: \"all\"}))\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\n//actions\r\n\r\n//альтернативная запись функции, кот. возвращ. только объект\r\n//as const чтобы typescript воспринимал ADD-TODOLIST не как строку, а как конст(именно весь объект)\r\nexport const removeTodolistAC = (todolistId: string) =>\r\n  ({type: 'REMOVE-TODOLIST', id: todolistId} as const)\r\nexport const addTodolistAC = (todolist: TodolistServerType) =>\r\n  ({type: 'ADD-TODOLIST', todolist} as const)\r\nexport const changeTodoListTitleAC = (id: string, title: string) =>\r\n  ({type: 'CHANGE-TODOLIST-TITLE', id, title} as const)\r\nexport const changeTodoListFilterAC = (id: string, filter: FilterValuesType) =>\r\n  ({type: 'CHANGE-TODOLIST-FILTER', id, filter} as const)\r\nexport const setTodolistsAC = (todolists: Array<TodolistServerType>) =>\r\n  ({type: 'SET-TODOLISTS', todolists} as const)\r\n\r\n\r\n//thunks\r\n\r\n// thunkCreator возвращает внутри себя санку (функция возвращает функцию)\r\nexport const fetchTodolistsTC = () => (dispatch: Dispatch<ActionsType>) => {\r\n    todolistsAPI.getTodolists()\r\n      //после ответа\r\n      .then(res => dispatch(setTodolistsAC(res)))\r\n}\r\nexport const removeTodolistTC = (todolistId: string) => (dispatch: Dispatch<ActionsType>) => {\r\n    todolistsAPI.deleteTodolist(todolistId)\r\n      //после ответа\r\n      .then(res => dispatch(removeTodolistAC(todolistId)))\r\n}\r\nexport const addTodolistTC = (title: string) => (dispatch: Dispatch<ActionsType>) => {\r\n    todolistsAPI.createTodolist(title)\r\n      //получаем с сервера\r\n      .then(res => dispatch(addTodolistAC(res.data.item)))\r\n}\r\nexport const changeTodolistTitleTC = (todolistId: string, title: string) => (dispatch: Dispatch<ActionsType>) => {\r\n    todolistsAPI.updateTodolist(todolistId, title)\r\n      //получаем с UI\r\n      .then(res => dispatch(changeTodoListTitleAC(todolistId, title)))\r\n}\r\n\r\n\r\n// types\r\n\r\n//типы для AC, кот. используются сразу в нескольких редьюсерах\r\n//т.к. их надо экспорт, мы создаем отдельные типы\r\nexport type AddTodoListActionType = ReturnType<typeof addTodolistAC>\r\nexport type RemoveTodoListActionType = ReturnType<typeof removeTodolistAC>\r\nexport type SetTodolistActionType = ReturnType<typeof setTodolistsAC>\r\n//правльная типизация AC-ов\r\ntype ActionsType =\r\n  | AddTodoListActionType\r\n  | RemoveTodoListActionType\r\n  | ReturnType<typeof changeTodoListTitleAC>\r\n  | ReturnType<typeof changeTodoListFilterAC>\r\n  | SetTodolistActionType\r\n\r\nexport type FilterValuesType = 'all' | 'active' | 'completed';\r\n//дополняем тип, приходящий с сервера тем, что нужно UI\r\nexport type TodolistBusinessType = TodolistServerType & {\r\n    filter: FilterValuesType\r\n}","import {AddTodoListActionType, RemoveTodoListActionType, SetTodolistActionType} from \"./todolists-reducer\";\r\nimport {TaskPriorities, tasksAPI, TaskStatuses, TaskType, UpdateTaskModelType} from \"../../api/api\";\r\nimport {Dispatch} from \"redux\";\r\nimport {AppRootStateType} from \"../../app/store\";\r\n\r\n// reducer\r\nconst initState: TasksStateType = {}\r\nexport const tasksReducer = (state: TasksStateType = initState, action: ActionsType): TasksStateType => {\r\n    switch (action.type) {\r\n        case 'REMOVE-TASK':\r\n            return {\r\n                ...state,\r\n                //в нужном листе (из action id) фильтруем все таски, кроме той, что пришла в action\r\n                [action.todolistId]: state[action.todolistId].filter(t => t.id !== action.taskId)\r\n            }\r\n        case 'ADD-TASK':\r\n            return {\r\n                ...state,\r\n                //находим в ассоциативном массиве по свойству в таске и подменяем на новый массив, где в начале будет\r\n                //новая таска из api, а дальше всё, что было раньше\r\n                [action.task.todoListId]: [action.task, ...state[action.task.todoListId]]\r\n            }\r\n        case 'UPDATE-TASK':\r\n            return {\r\n                ...state,\r\n                //находим в ассоциативном массиве нужный лист по свойству в action\r\n                //map возвращает копию массива и пробегается по таскам, ищем нужную таску по свойству в action\r\n                //и меняем таску на копию с измененной моделькой из action (в ней сидит одно из свойств, кот. изм.)\r\n                [action.todolistId]: state[action.todolistId].map(task =>\r\n                  task.id === action.taskId ? {...task, ...action.model} : task)\r\n            }\r\n      //в этих редьюсерах мы должны обрабатывать action todolist редьюсера,\r\n      //так как, меняя листы, мы меняем и вторую часть стейта, отвечающуую за их таски\r\n        case 'ADD-TODOLIST':\r\n            return {\r\n                ...state,\r\n                //добавляя новый лист, создаем пустой массив для его тасок\r\n                [action.todolist.id]: []\r\n            }\r\n        case 'REMOVE-TODOLIST': {\r\n            //скобки, т.к. создаем переменные\r\n            //нельзя записью прямо в объекте удалить массив тасок\r\n            const stateCopy = {...state};\r\n            delete stateCopy[action.id]\r\n            return stateCopy\r\n        }\r\n        case 'SET-TODOLISTS': {\r\n            const stateCopy = {...state};\r\n            //map создает массив, а forEach меняет существующий\r\n            //когда нам приходят листы с api, создаем для каждого пустой массив для их тасок\r\n            action.todolists.forEach(tl => {\r\n                stateCopy[tl.id] = []\r\n            })\r\n            return stateCopy\r\n        }\r\n        case 'SET-TASKS':\r\n            return {\r\n                ...state,\r\n                //находим нужный лист в ассоц. массиве по id из action и пихаем в него таски из action\r\n                [action.todolistId]: action.tasks\r\n            }\r\n        default:\r\n            return state\r\n    }\r\n}\r\n\r\n//actions\r\n\r\n//альтернативная запись функции, кот. возвращ. только объект\r\n//as const чтобы typescript воспринимал ADD-TODOLIST не как строку, а как конст(именно весь объект)\r\n//тоже самое что todolistId: todolistId, taskId: taskId\r\nexport const removeTaskAC = (todolistId: string, taskId: string) =>\r\n  ({type: 'REMOVE-TASK', todolistId, taskId} as const)\r\nexport const addTaskAC = (task: TaskType) =>\r\n  ({type: 'ADD-TASK', task} as const)\r\nexport const updateTaskAC = (todolistId: string, taskId: string, model: UpdateBusinessTaskModelType) =>\r\n  ({type: 'UPDATE-TASK', taskId, todolistId, model} as const)\r\nexport const setTasksAC = (tasks: Array<TaskType>, todolistId: string) =>\r\n  ({type: 'SET-TASKS', tasks, todolistId} as const)\r\n\r\n\r\n//thunks\r\n\r\n// thunkCreator возвращает внутри себя санку (функция возвращает функцию(\r\n//после первой функции => сразу возвращаем вторую (dispatch) =>\r\nexport const fetchTasksTC = (todolistId: string) =>\r\n  //возвращаем санку ( анонимная функция(название не имеет смысла))\r\n  (dispatch: Dispatch<ActionsType>) => {\r\n      tasksAPI.getTasks(todolistId)\r\n        //после ответа\r\n        .then(res => dispatch(setTasksAC(res.items, todolistId)))\r\n  }\r\nexport const deleteTaskTC = (todolistId: string, taskId: string) =>\r\n  //возвращаем санку ( анонимная функция(название не имеет смысла))\r\n  (dispatch: Dispatch<ActionsType>) => {\r\n      //сначала делаем запрос на сервер на удаление таски\r\n      tasksAPI.deleteTask(todolistId, taskId)\r\n        //только потом диспатчим изменение в наш state\r\n        .then(res => {\r\n              const action = removeTaskAC(todolistId, taskId)\r\n              dispatch(action)\r\n          }\r\n        )\r\n  }\r\nexport const addTaskTC = (todolistId: string, title: string) =>\r\n  //возвращаем санку ( анонимная функция(название не имеет смысла))\r\n  (dispatch: Dispatch<ActionsType>) => {\r\n      tasksAPI.createTask(todolistId, title)\r\n        .then(res => dispatch(addTaskAC(res.data.item)))\r\n  }\r\nexport const updateTaskTC = (todolistId: string, taskId: string, businessModel: UpdateBusinessTaskModelType) =>\r\n  //возвращаем санку ( анонимная функция(название не имеет смысла))\r\n  (dispatch: Dispatch<ActionsType>, getState: () => AppRootStateType) => {\r\n      const state = getState()\r\n      //ищем нужную таскую\r\n      const task = state.tasks[todolistId].find(t => t.id === taskId)\r\n      //на случай, если произойдет внештатная ошибка\r\n      if (!task) {\r\n          console.warn(\"task was not found in the state\")\r\n          return\r\n      }\r\n      //меняем только статус, остальное берем из getState\r\n      const serverModal: UpdateTaskModelType = {\r\n          //не делаем копию с помощью {...task, status: status} потому что в task находятся лишние данные\r\n          //не нужные серву (todoId, addedDate, id)\r\n          deadline: task.deadline,\r\n          description: task.description,\r\n          priority: task.priority,\r\n          startDate: task.startDate,\r\n          status: task.status,\r\n          title: task.title,\r\n          //тут будет 1 нужное для перезатирания свойство, оно перезапишет в serverModel\r\n          ...businessModel\r\n      }\r\n      tasksAPI.updateTask(todolistId, taskId, serverModal)\r\n        .then(res => dispatch(updateTaskAC(todolistId, taskId, businessModel)))\r\n  }\r\n\r\n\r\n// types\r\n\r\n//правльная типизация AC-ов\r\ntype ActionsType =\r\n  | ReturnType<typeof removeTaskAC>\r\n  | ReturnType<typeof addTaskAC>\r\n  | ReturnType<typeof updateTaskAC>\r\n  | ReturnType<typeof setTasksAC>\r\n  | AddTodoListActionType\r\n  | RemoveTodoListActionType\r\n  | SetTodolistActionType\r\nexport type TasksStateType = {\r\n    [key: string]: Array<TaskType>\r\n}\r\n//тип нужен, чтобы сделать 1 TC на несколько операций апдейта таски, чтобы не отправлять сразу всё\r\nexport type UpdateBusinessTaskModelType = {\r\n    title?: string\r\n    description?: string\r\n    status?: TaskStatuses\r\n    priority?: TaskPriorities\r\n    startDate?: string | null\r\n    deadline?: string | null\r\n}\r\n","import {applyMiddleware, combineReducers, createStore} from \"redux\";\r\nimport {todolistsReducer} from \"../features (pages)/TodolistsList/todolists-reducer\";\r\nimport {tasksReducer} from \"../features (pages)/TodolistsList/tasks-reducer\";\r\nimport thunk from \"redux-thunk\";\r\n\r\nconst rootReducer = combineReducers({\r\n    todolists: todolistsReducer,\r\n    tasks: tasksReducer,\r\n})\r\n\r\n//создаем стор, дополняя его своим стейтом и подключаем Middleware из thunk\r\nexport const store = createStore(rootReducer, applyMiddleware(thunk))\r\n\r\n//автоматическая типизация\r\nexport type AppRootStateType = ReturnType<typeof rootReducer>\r\n\r\n\r\n\r\n\r\n// а это, чтобы можно было в консоли браузера обращаться к store в любой момент\r\n// @ts-ignore\r\nwindow.store = store;","import React, {ChangeEvent, KeyboardEvent, useState} from 'react';\r\nimport {IconButton, TextField} from \"@material-ui/core\";\r\nimport {AddBox} from \"@material-ui/icons\";\r\n\r\ntype AddItemFormPropsType = {\r\n    addItem: (title: string) => void\r\n}\r\n\r\n//React.memo предотвращает перерисовку когда приходят такие же пропсы\r\n//но т.к. нам приходит каждый раз одинаковый(для человека) коллбэк, а func это obj, а одинаковые объекты не равны\r\n//все равно происходит перерисовка, поэтому useCallback в addTask\r\nexport const AddItemForm = React.memo(function(props: AddItemFormPropsType) {\r\n    console.log(\"AddItemForm rendered\")\r\n\r\n    /*локальный стейт инпута, синхронизируем value инпута с отрисовкой по клику новой таски в title*/\r\n    let [title, setTitle] = useState<string>(\"\");\r\n    let [error, setError] = useState<string | null>(null)\r\n\r\n    /*пихает из локального стейта в функцию addTask в App* и удаляет пробелы */\r\n    const addItem = () => {\r\n        if (title.trim() !== \"\") {\r\n            props.addItem(title);\r\n            setTitle(\"\")\r\n        } else {\r\n            setError(\"Title is not required\")\r\n        }\r\n    };\r\n    /*перерисовка инпута, засовываем в локал стейт впечатанное значение инпута и убираем ошибку, впечатывая*/\r\n    const onChangeHandler = (e: ChangeEvent<HTMLInputElement>) => {\r\n        setTitle(e.currentTarget.value);\r\n        setError(null);\r\n    };\r\n    /*если нажат интер, то пихнуть в App*/\r\n    const onKeyPressHandler = (e: KeyboardEvent<HTMLInputElement>) => {\r\n        //чтобы setError не занулял ошибку при каждом нажатии клавиши\r\n        if (error !== null) {\r\n            setError(null)\r\n        }\r\n        e.charCode === 13 && addItem()\r\n    }\r\n\r\n    return (\r\n      <div>\r\n          <TextField value={title}\r\n                     onChange={onChangeHandler}\r\n                     onKeyPress={onKeyPressHandler}\r\n                     variant=\"outlined\"\r\n            //Псевдоистина, тс блочит автомат. преобр. строки в булево, поэтому оператором делаем вручную\r\n                     error={!!error}\r\n                     label={\"Title\"}\r\n                     helperText={error}\r\n          />\r\n          <IconButton color=\"primary\" onClick={addItem}>\r\n              <AddBox/>\r\n          </IconButton>\r\n      </div>\r\n    )\r\n} );\r\n\r\n\r\nexport default AddItemForm;","import React, {ChangeEvent, KeyboardEvent, useState} from \"react\";\r\nimport {TextField} from \"@material-ui/core\";\r\n\r\ntype EditableSpanPropsType = {\r\n    title: string;\r\n    onChange: (newTitle: string) => void\r\n}\r\n\r\nconst EditableSpan = React.memo( (props: EditableSpanPropsType) => {\r\n    console.log(\"EditableSpan is called\")\r\n    let [editMode, setEditMode] = useState(false);\r\n    let [title, setTitle] = useState<string>(\"\");\r\n\r\n    const activateEditMode = () => {\r\n        setEditMode(true);\r\n        setTitle(props.title);\r\n    }\r\n\r\n    const  activateViewMode = () => {\r\n        setEditMode(false);\r\n        props.onChange(title)\r\n    }\r\n\r\n    const onChangeHandler = (e: ChangeEvent<HTMLInputElement>) => setTitle(e.currentTarget.value);\r\n    const onKeyPressHandler = (e: KeyboardEvent<HTMLInputElement>) =>  e.charCode === 13 && activateViewMode();\r\n\r\n    return editMode\r\n      ? <TextField value={title}\r\n               autoFocus\r\n               onBlur={() => activateViewMode() }\r\n               onChange={onChangeHandler}\r\n               onKeyPress={onKeyPressHandler}\r\n      />\r\n      : <span onDoubleClick={() => activateEditMode() }>{props.title}</span>\r\n} );\r\n\r\nexport default EditableSpan;","import {useDispatch} from \"react-redux\";\r\nimport {deleteTaskTC, updateTaskTC} from \"../../tasks-reducer\";\r\nimport React, {ChangeEvent, useCallback} from \"react\";\r\nimport {Checkbox, IconButton} from \"@material-ui/core\";\r\nimport {Delete} from \"@material-ui/icons\";\r\nimport {FilterValuesType} from \"../../todolists-reducer\";\r\nimport {TaskStatuses, TaskType} from \"../../../../api/api\";\r\nimport EditableSpan from \"../../../../components (common)/EditableSpan/EditableSpan\";\r\n\r\ntype TaskPropsType = {\r\n    task: TaskType\r\n    filter: FilterValuesType\r\n    todolistId: string\r\n\r\n}\r\nexport const Task = React.memo((props: TaskPropsType) => {\r\n    const dispatch = useDispatch();\r\n\r\n    const RemoveTask = useCallback(() => {\r\n        dispatch(deleteTaskTC(props.todolistId, props.task.id))\r\n        },\r\n        //массив зависимостей (все, что используем извне)\r\n        [dispatch, props.task.id, props.todolistId]);\r\n    const ChangeTaskStatus = useCallback((e: ChangeEvent<HTMLInputElement>) => {\r\n        let newStatusValue = e.currentTarget.checked;\r\n        //отправляем в модельке только нужное для изменения свойство\r\n        dispatch(updateTaskTC(props.todolistId, props.task.id, {status: newStatusValue ? TaskStatuses.Completed : TaskStatuses.New}));\r\n    }, [dispatch, props.task.id, props.todolistId]);\r\n    const ChangeTaskTitle = useCallback((newValue: string) =>\r\n            //отправляем в модельке только нужное для изменения свойство\r\n            dispatch(updateTaskTC(props.todolistId, props.task.id, {title: newValue},)),\r\n        [dispatch, props.task.id, props.todolistId]);\r\n\r\n    return (\r\n        <li key={props.task.id}\r\n            className={props.filter !== \"completed\" && props.task.status === TaskStatuses.Completed ? \"is-done\" : \"\"}>\r\n            {/*прозрачный класс добавится когда таска чекнута и не в фильтре комплитед*/}\r\n            <Checkbox checked={props.task.status === TaskStatuses.Completed} onChange={ChangeTaskStatus}\r\n                      color=\"primary\"/>\r\n            <EditableSpan title={props.task.title} onChange={ChangeTaskTitle}/>\r\n            <IconButton onClick={RemoveTask}>\r\n                <Delete/>\r\n            </IconButton>\r\n        </li>\r\n    )\r\n});","import React, {useCallback, useEffect} from 'react'\r\nimport {Button, ButtonGroup, IconButton} from \"@material-ui/core\";\r\nimport {Delete, Home} from \"@material-ui/icons\";\r\nimport {useDispatch, useSelector} from \"react-redux\";\r\nimport {AppRootStateType} from \"../../../app/store\";\r\nimport {addTaskTC, fetchTasksTC} from \"../tasks-reducer\";\r\nimport {\r\n    changeTodoListFilterAC,\r\n    changeTodolistTitleTC,\r\n    FilterValuesType,\r\n    removeTodolistTC\r\n} from \"../todolists-reducer\";\r\nimport {Task} from \"./Task/Task\";\r\nimport {TaskStatuses, TaskType} from \"../../../api/api\";\r\nimport AddItemForm from \"../../../components (common)/AddItemForm/AddItemForm\";\r\nimport EditableSpan from \"../../../components (common)/EditableSpan/EditableSpan\";\r\n\r\ntype TodoListPropsType = {\r\n    id: string\r\n    title: string\r\n    filter: FilterValuesType\r\n}\r\n\r\nexport const Todolist = React.memo((props: TodoListPropsType) => {\r\n    console.log(\"Todolist is called\")\r\n    const dispatch = useDispatch()\r\n\r\n\r\n    //первый дженерик тип глобал стейта, второй того, что мы селектим\r\n    //вместо mapStateToProps, храним здесь стейт, нужный для этой компоненты\r\n    const allTodoListTasks = useSelector<AppRootStateType, Array<TaskType>>(state => state.tasks[props.id])\r\n\r\n    //в неё кладем отсортированные таски (создаем тут, чтобы не создавать в каждом case)\r\n    //let потому что делаем ниже присваивания\r\n    let tasksForTodoList: Array<TaskType>;\r\n    switch (props.filter) {\r\n        case \"active\" :\r\n            tasksForTodoList = allTodoListTasks.filter(task => task.status === TaskStatuses.New)\r\n            break;\r\n        case \"completed\" :\r\n            tasksForTodoList = allTodoListTasks.filter(task => task.status === TaskStatuses.Completed)\r\n            break;\r\n        default :\r\n            tasksForTodoList = allTodoListTasks;\r\n            break;\r\n    }\r\n\r\n    //запоминает функцию и т.к. пустой [], то никогда не создавай новую функцию\r\n    //disp и AC не меняется и можно его не добавлять\r\n    //обязательно вставляем всё, от чего зависит функция извне (props.id)\r\n    const addTask = useCallback((title: string) => dispatch(addTaskTC(props.id, title)), [dispatch, props.id]);\r\n    const removeTodoList = useCallback(() => dispatch(removeTodolistTC(props.id)), [dispatch, props.id]);\r\n    const changeTodoListTitle = useCallback((newTitle: string) => {\r\n        const thunk = changeTodolistTitleTC(props.id, newTitle);\r\n        dispatch(thunk)\r\n    }, [dispatch, props.id]);\r\n    //предполагаем, что в Button от MatUI внутри тоже есть React.memo, поэтому оборачиваем передаваемых в них коллбэк в useCallback\r\n    const changeFilter = useCallback((id: string, value: FilterValuesType) => dispatch(changeTodoListFilterAC(props.id, value)), [dispatch, props.id]);\r\n\r\n\r\n    useEffect(() => {\r\n        dispatch(fetchTasksTC(props.id))\r\n    }, [dispatch, props.id])\r\n\r\n    return (\r\n        <div>\r\n            <h3>\r\n                <EditableSpan title={props.title} onChange={changeTodoListTitle}/>\r\n                <IconButton onClick={removeTodoList}>\r\n                    <Delete/>\r\n                </IconButton>\r\n            </h3>\r\n            <AddItemForm addItem={addTask}/>\r\n            <ul>\r\n                {tasksForTodoList.map(task =>\r\n                    <Task\r\n                        task={task}\r\n                        filter={props.filter}\r\n                        todolistId={props.id}\r\n                        key={task.id}\r\n                    />)}\r\n            </ul>\r\n            <div>\r\n                <ButtonGroup>\r\n                    <Button onClick={() => changeFilter(props.id, \"all\")}\r\n                            variant={props.filter === \"all\" ? \"contained\" : \"outlined\"}\r\n                            color=\"primary\" endIcon={<Home/>}>All</Button>\r\n                    <Button onClick={() => changeFilter(props.id, \"active\")}\r\n                            variant={props.filter === \"active\" ? \"contained\" : \"outlined\"}\r\n                            color=\"inherit\">Active</Button>\r\n                    <Button onClick={() => changeFilter(props.id, \"completed\")}\r\n                            variant={props.filter === \"completed\" ? \"contained\" : \"outlined\"}\r\n                            color=\"secondary\">Completed</Button>\r\n                </ButtonGroup>\r\n            </div>\r\n        </div>\r\n    )\r\n});\r\n\r\n\r\n","import React, {useCallback, useEffect} from \"react\";\r\nimport {useDispatch, useSelector} from \"react-redux\";\r\nimport {AppRootStateType} from \"../../app/store\";\r\nimport {addTodolistTC, fetchTodolistsTC, TodolistBusinessType} from \"./todolists-reducer\";\r\nimport {Grid, Paper} from \"@material-ui/core\";\r\nimport AddItemForm from \"../../components (common)/AddItemForm/AddItemForm\";\r\nimport {Todolist} from \"./Todolist/Todolist\";\r\n\r\nexport const TodolistsList = React.memo(() => {\r\n    const dispatch = useDispatch();\r\n\r\n    const todolists = useSelector<AppRootStateType, Array<TodolistBusinessType>>(state => state.todolists)\r\n\r\n    //запоминает функцию и т.к. пустой [], то никогда не создавай новую функцию при перерисовке\r\n    //добавляем dispatch в [], просто чтобы реакт не ругался в консоли (disp не меняется и можно было бы его не добавлять)\r\n    const addTodoList = useCallback((title: string) => dispatch(addTodolistTC(title)), [dispatch])\r\n\r\n    useEffect(() => {\r\n        //самая первая загрузка листов\r\n        dispatch(fetchTodolistsTC())\r\n    }, [dispatch])\r\n\r\n    return (\r\n      <>\r\n          <Grid container style={{padding: \"20px\"}}>\r\n              <AddItemForm addItem={addTodoList}/>\r\n          </Grid>\r\n          <Grid container spacing={3}>\r\n              {\r\n                  todolists.map(todolist => {\r\n\r\n                      return (\r\n                        <Grid item key={todolist.id}>\r\n                            <Paper style={{padding: \"10px\"}}>\r\n                                <Todolist\r\n                                  id={todolist.id}\r\n                                  title={todolist.title}\r\n                                  filter={todolist.filter}\r\n                                />\r\n                            </Paper>\r\n                        </Grid>\r\n                      )\r\n                  })\r\n              }\r\n          </Grid>\r\n      </>)\r\n});","import React from 'react';\r\nimport './App.css';\r\nimport {AppBar, Button, Container, IconButton, Menu, Toolbar, Typography} from \"@material-ui/core\";\r\nimport {TodolistsList} from \"../features (pages)/TodolistsList/TodolistsList\";\r\n\r\nfunction App() {\r\n    return (\r\n      <div className=\"App\">\r\n          <AppBar position=\"static\">\r\n              <Toolbar>\r\n                  <IconButton edge=\"start\" color=\"inherit\" aria-label=\"menu\">\r\n                      <Menu open={false}/>\r\n                  </IconButton>\r\n                  <Typography variant=\"h6\">\r\n                      News\r\n                  </Typography>\r\n                  <Button color=\"inherit\">Login</Button>\r\n              </Toolbar>\r\n          </AppBar>\r\n          <Container fixed>\r\n              <TodolistsList/>\r\n          </Container>\r\n      </div>\r\n    )\r\n}\r\n\r\nexport default App;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport {Provider} from \"react-redux\";\r\nimport {store} from \"./app/store\";\r\nimport App from './app/App';\r\n\r\nReactDOM.render(\r\n  //провайдер расшаривает стор для всех своих детей\r\n  <Provider store={store}>\r\n      <App/>\r\n  </Provider>,\r\n\r\n  document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\n"],"sourceRoot":""}